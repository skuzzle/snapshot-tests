= Snapshot-Tests User Guide
Simon Taddiken
:toc:
:toclevels: 4
:sectnums:
:sectnumlevels: 4
:revnumber: {project-version}
:example-caption!:
:imagesdir: ./images
ifndef::sourcedir[:sourcedir: ../../test/java]

This is a user manual for an example project.

== Introduction

This library allows to conveniently assert on the structure and contents of complex objects. It does so by storing a 
serialized version of the object during the first test execution and during subsequent test executions, compare the 
actual object against the stored snapshot.

Read more about _snapshot testing_ in this accompanying https://simon.taddiken.net/the-case-for-snapshot-testing[blog post].

== Artifacts

The library comes with different modules that can be used and combined to fulfill different testing purposes. As such 
it is not uncommon that you want to include multiple modules in your project's dependencies. 

[source,xml,subs="attributes+"]
.Maven BOM artifact
----
<dependencyManagement>
    <dependency>
        <groupId>de.skuzzle.test</groupId>
        <artifactId>snapshot-tests-bom</artifactId>
        <version>{revnumber}</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
</dependencyManagement>
----

[source,groovy,subs="attributes+"]
.Gradle BOM include
----
testImplementation(platform("de.skuzzle.test:snapshot-tests-bom:{revnumber}"))
----

=== Modules
The following modules are managed in the previously mentioned BOM artifact. Follow the remaining documentation to 
learn how to properly combine them to employ _snapshot testing_ in your own project. 

.Available modules. Click the module's name to view it on Maven Central.
|===
|Module name|Description

|https://search.maven.org/artifact/de.skuzzle.test/snapshot-tests-core/{revnumber}/jar[`snapshot-tests-core`]
| Core API and unstructured text comparison. 


|https://search.maven.org/artifact/de.skuzzle.test/snapshot-tests-jackson/{revnumber}/jar[`snapshot-tests-jackson`]
| JSON snapshot serialization using `jackson` and structured comparison using `jsonassert`.


|https://search.maven.org/artifact/de.skuzzle.test/snapshot-tests-jaxb/{revnumber}/jar[`snapshot-tests-jaxb`]
| XML snapshot serialization using `jaxb` and structured comparison using `xmlunit`.

|https://search.maven.org/artifact/de.skuzzle.test/snapshot-tests-directory-params/{revnumber}/jar[`snapshot-tests-directory-params`]
| JUnit5 `ArgumentProvider` implementations that allow to iterate over files/directories. 
|===

NOTE: If you use the `-jackson` or `-jaxb` module there is no need to additionally declare a dependency to the 
`-core` module.

=== Versioning, Compatibility and Upgrading
This project strongly aims to provide a stable public API with little surprises for clients when they upgrade to a new 
version. We rely on the principles of _semantic versioning_ and use 
https://github.com/apiguardian-team/apiguardian[@API Guardian] to communicate the intention of all of public 
classes/methods. Consequently you should not use any public types that are marked as `INTERNAL`.

The following principles apply:

* Upgrading to a newer _patch_ or _minor_ version should never break client code or existing tests.
* Upgrading to a newer _major_ version can potentially break client code or tests.
* All deprecations will be marked clearly in code an alternatives will be presented in the JavaDoc.
* Deprecated code will be removed in accordance to the code's previous API Guardian `status`. 

NOTE: It is possible that snapshot header information change even during a patch/minor update. This might cause your 
snapshot files to occur as _modified_ files in your local SCM copy after upgrading to a newer framework version.

== Getting started

This is a very simple quick start example of how to use this framework, relying only on the `-core` module and the 
test result's `toString()` representation. 

.Simple quick start example
====
[source,java]
----
include::{sourcedir}/de/skuzzle/test/snapshots/snippets/QuickstartTest.java[tags=quickstart,indent=0]
----
<1> Enable the _JUnit5_  extension for your test class.
<2> Declare a parameter of type `Snapshot`. It will be injected by the framework.
<3> Choose a serialization format. Here we use the `actual` object's `toString()` representation as snapshot format.
<4> Perform the assertion by comparing the actual object with the persisted snapshot.
====

=== General Snapshot testing workflow

. Implement test cases and add one ore more snapshot assertions as shown above.
. When you execute these tests the _first_ time, serialized snapshots of your test results will be persisted and _the tests will fail_.
. Execute the same tests again. Now, the framework will compare the test results against the persisted snapshots. If your code under test produces deterministic results, tests should now be green.
. Check in the persisted snapshots into your SCM.

[IMPORTANT]
====
The framework will fail all snapshot assertions when they are initially executed and there is no previous 
snapshot file to compare the current result against. This guards against accidently checking in broken or flaky tests 
into your SCM.
[source]
.Assertion error after snapshots have been created initially
----
java.lang.AssertionError: Snapshots have been created the first time.
Run the test again and you should see it succeed.
----
====

TIP: If you find that your tests are flaky or continue to fail even after the initial test execution, take a look at 
the section about dealing with <<random-values-in-test-results,random values>>.


== Basic Usage

=== Entrypoint
As shown in the <<getting-started, Getting Started>> section, you need to enable snapshot tests capabilities for your 
test class by annotating it with `@EnabledSnapshotTests`. This registers a _JUnit5_ `ArgumentResolver` which 
takes care of injecting a `Snapshot` instance into your test methods. The `Snapshot` interface is the entrypoint 
for the _assertion DSL_

=== Snapshot serialization
The framework needs to create a `String` representation of you test results in order to store it in a _snapshot file_. 
We distinguish between _just text_ and _structured text_ snapshots. This distinction influences the way in which new 
test results can be compared to persisted snapshots:

* If a snapshot uses a _structured format_ such as `XML` or `JSON` the framework can make use of that structure during 
comparison to offer better error messages or to allow customization of the comparison details. 
* If a snapshot consists of _just text_ the framework can only make a text comparison.

==== Text-only comparison
In order to present a meaningful _assertion failed_ message the framework will always create a unified diff of the
persisted snapshot and the serialized `actual` result. 

.Serialize without structured format and apply text-only comparison.
====
[source,java]
----
include::{sourcedir}/de/skuzzle/test/snapshots/snippets/ComparisonTests.java[tags=text-compare,indent=0]
----
<1> `.matchesSnapshotText()` is _the only_ available option when you choose no structured format using `asText()`.
====

If the assertions fails because a difference has been found, the framework will provide a rich failure report along 
with the assertion error's stack trace.

[source]
.Example text comparison failure.
----
org.opentest4j.AssertionFailedError: Stored snapshot doesn't match actual result.

Snapshot location:
    src\test\resources\de\skuzzle\test\snapshots\snippets\ComparisonTests_snapshots\testCreateSnapshotAsText_0.snapshot

Full unified diff of actual result and stored snapshot:
Name: -[Simon]+[Peter]
Surname: -[Taddike]+[Pa]n
Birthdate: 1777-01-12
Address: Street: Gibtsnicht-Straße
Number: 1337
Zip: 4711
City: Bielefeld
Country: Germany


    at de.skuzzle.test.snapshots.snippets.ComparisonTests.testCreateSnapshotAsText(ComparisonTests.java:29)
    [...]
----

Most IDEs will additionally allow you to display the differences in a dedicated diff viewer. For example, if you double 
click the assertion failure in eclipse's _Failure Trace_ view you will be presented with the following view.
[#img-eclipse_diff]
.The same assertion error as displayed in eclipse's diff viewer.
image::eclipse_diff.jpg[align=center]

NOTE: Displaying multiple differences _at once_ is one key strength of snapshot testing. It gives you the value of 
`n` assertions for only writing a *single* one.


==== Structural comparison
When using a structured serialization format you can make use of advanced comparison features offered by the respective 
format. See <<snapshot-formats, Snapshot formats>> to learn more about customizing the serialization and comparison 
details.

.Serialize to JSON and apply structural comparison.
====
[source,java]
----
include::{sourcedir}/de/skuzzle/test/snapshots/snippets/ComparisonTests.java[tags=structure-compare-json,indent=0]
----
<1> Choose to serialize test results as JSON.
<2> Choose `.matchesSnapshotStructure()` to trigger structural comparison.
====

When comparison fails, the framework enhances the failure message with additional information from the structural 
comparison.
[source]
.Example structural comparison failure for JSON snapshots.
----
org.opentest4j.AssertionFailedError: name
Expected: Simon
     got: Peter
 ; surname
Expected: Taddiken
     got: Pan


Snapshot location:
    src\test\resources\de\skuzzle\test\snapshots\snippets\ComparisonTests_snapshots\testCreateSnapshotAsJson_0.snapshot

Full unified diff of actual result and stored snapshot:
{
  "name" : "-[Simon]+[Peter]",
  "surname" : "-[Taddike]+[Pa]n",
  "birthdate" : "1777-01-12",
  "address" : {
    "street" : "Gibtsnicht-Straße",
    "number" : "1337",
    "zipCode" : "4711",
    "city" : "Bielefeld",
    "country" : "Germany"
  }
}
    at de.skuzzle.test.snapshots.snippets.ComparisonTests.testCreateSnapshotAsJson(ComparisonTests.java:41)
    [...]
----

Likewise for `XML` serialization:

.Serialize to XML and apply structural comparison.
====
[source,java]
----
include::{sourcedir}/de/skuzzle/test/snapshots/snippets/ComparisonTests.java[tags=structure-compare-xml,indent=0]
----
====

[source]
.Example structural comparison failure for XML snapshots.
----
org.opentest4j.AssertionFailedError: 

Expecting:
 <control instance> and <test instance> to be identical
Expected text value 'Simon' but was 'Peter' - comparing <name ...>Simon</name> at /person[1]/name[1]/text()[1] to <name ...>Peter</name> at /person[1]/name[1]/text()[1]
Expected :<<name>Simon</name>>
Actual   :<<name>Peter</name>>


Snapshot location:
    src\test\resources\de\skuzzle\test\snapshots\snippets\ComparisonTests_snapshots\testCreateSnapshotAsXml_0.snapshot

Full unified diff of actual result and stored snapshot:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<person>
    <address>
        <city>Bielefeld</city>
        <country>Germany</country>
        <number>1337</number>
        <street>Gibtsnicht-Straße</street>
        <zipCode>4711</zipCode>
    </address>
    <birthdate/>
    <name>-[Simon]+[Peter]</name>
    <surname>-[Taddike]+[Pa]n</surname>
</person>

    at de.skuzzle.test.snapshots.snippets.ComparisonTests.testCreateSnapshotAsXml(ComparisonTests.java:53)
    [...]
----


=== Updating snapshots
One aspect that makes _snapshot testing_ so powerful is, that you can generate the _expected output_ from your 
_code under test_ itself. This removes the necessity to manually update test cases when the behavior of your 
code under test changes. The framework comes with a convenient approach for updating multiple snapshot files at once. 
You should stick to the following workflow:

. Make the desired changes to your code under test. If you run the snapshot tests now they should fail.
. Advise the framework to update the snapshot files with the latest actual results. 
. Inspect the changes within your snapshot files to see whether they reflect your desired outcome (your 
SCM should mark the changed files as _modified_ and should thus be able display a neat diff to the previous version). 
. Remove the advice to update snapshots.

[IMPORTANT]
====
Whenever the framework overrides a snapshot with the new actual test result, the respective assertion will 
fail. As already stated in the <<general-snapshot-testing-workflow, Getting Started>> section, this is to prevent you 
from accidently checking in broken tests into your SCM.

[source]
.Assertion error after forcefully updating snapshots
----
java.lang.AssertionError: Snapshots have been updated forcefully.
Remove 'updateSnapshots = true' attribute, @ForceUpdateSnapshots annotation, -DforceUpdateSnapshots JVM flag and calls to 'justUpdateSnapshot()' and run the tests again.
----  
====

==== Update multiple snapshots within the same test
You can place the `@ForceUpdateSnapshots` annotation on either your test method or your whole test class to advise 
the framework to update the snapshots of all affected assertions.

.Update the snapshots for all assertions in the same test method
====
[source,java]
----
include::{sourcedir}/de/skuzzle/test/snapshots/snippets/UpdatingSnapshots.java[tags=force-update-on-method,indent=0]
----
====

.Update the snapshots for all assertions in the same test class
====
[source,java]
----
include::{sourcedir}/de/skuzzle/test/snapshots/snippets/UpdatingSnapshots.java[tags=force-update-on-class,indent=0]
----
====

NOTE: You might find it irritating that the `@ForceUpdateSnapshots` annotation is marked as deprecated. This is just 
a hack to make your IDE highlight its usages as it is intended to be only used temporarily. 

==== Update the snapshots for the whole project
Snapshots can also be updated globally by passing the `-DforceUpdateSnapshots` parameter to the JVM. This will 
update the snapshots of all tests executed within the JVM. 

[TIP]
====
When using `maven` you can pass the option to the `surefire-plugin` on the command line using this little trick:
 
 mvn clean verify -DargLine=-DforceUpdateSnapshots
====

TIP: Handling of the parameter is case-insensitive.


==== Updating the snapshot for a single assertion
You can replace the call to `.matchesSnapshotText()` or `.matchesSnapshotStructure()` of your assertion with 
`.justUpdateSnapshot()`. When executing the test, the framework will simply override the existing snapshot for this
assertion with the passed in `actual` result.

[source,java]
.Change the assertion to update the snapshot file
----
include::{sourcedir}/de/skuzzle/test/snapshots/snippets/UpdatingSnapshots.java[tags=justupdate,indent=0]
----
<1> Temporarily remove the actual assertion and replace it with `justUpdateSnapshot()`.


=== Snapshot files
By convention, snapshots of your test results are persisted as `.snapshot` files below `src/test/resources`. The 
framework will create sub directories according to your test class's package and name. The snapshot file's name will 
be determined from the respective test's method name. 

The snapshot file does not only include the serialized test result but also a small header section containing some 
meta information. These information are use by the framework to map the snapshot file to the test method and 
assertion from which it was created.


==== Changing the snapshot location
The location where

==== Changing the snapshot file name
In order to store persisted snapshots, the framework will determine a proper location and file name from the name of 
the respective test class and test method.  


==== Orphaned files
Snapshot files can become _orphans_ if you rename or delete test methods/classes. It is desirable to remove orphaned 
snapshots as they will otherwise just add clutter to your repository. The framework comes with a sophisticated 
approach for detecting and removing such orphaned files.

By default, the framework will just log a warning like this to the console about detected orphan files:
[source]
.Warning about detected orphan file
----
WARNING: Found orphaned snapshot file. Run with @DeleteOrphanedSnapshots annotation to remove: testThatHasBeenDeleted_0.snapshot in src/test/resources/de/skuzzle/test/snapshots/impl/OrphanedSnapshotDetectionTest$TestCase_snapshots
----

There are a number of situations in which a snapshot can become an orphan:

* The test method containing the snapshot assertion has been removed/renamed.
* The test class containing the test with the snapshot assertion has been removed/renamed.
* The test is no longer a snapshot test.
* Another snapshot assertion has been added/removed to/from the same test method. 

.Info about orphan detection
****
Orphan detection is not a straight forward task and quite a lot complexity within the implementation of this library 
comes from solving this task.

For example, just by examining a snapshot file, the framework can't reliably determine whether the test still contains
the _snapshot assertion statement_ that created the file in the first place. 

On the other hand there are some criteria that _can_ be examined _statically_. As the snapshot file's header 
information contain the full qualified name of the test class and the name of the test method, it is quite easy to 
determine whether those still exists or not.

Consequently, orphan detection implementation is separated into two phases:

. During _dynamic orphan detection_, the framework collects the actual snapshot results of all executed tests. Then it checks all existing snapshot files for whether there exists a matching result.   
. During _static orphan detection_, the framework examines the header information of all snapshot files to determine whether their originating class/test still exist.

CAUTION: This approach has the drawback that orphans can be reported falsely if you only run a subset of your test suite.  
****


You can advise the framework to automatically delete the detected orphaned files during a test run. This works similar
to updating snapshot files by either adding an annotation or by passing a flag to the JVM.

.Delete detected orphans during test execution
====
[source,java]
----
include::{sourcedir}/de/skuzzle/test/snapshots/snippets/DeleteOrphansTest.java[tags=delete-orphans,indent=0]
----
<1> Temporarily add the `@DeleteOrphanedSnapshots` annotations during test execution
====

NOTE: You might find it irritating that the `@DeleteOrphanedSnapshots` annotation is marked as deprecated. This is just 
a hack to make your IDE highlight its usages as it is intended to be only used temporarily. 


You can also pass the flag `-DdeleteOrphanedSnapshots` to the JVM.

[TIP]
====
When using `maven` you can pass the option to the `surefire-plugin` on the command line using this little trick:
 
 mvn clean verify -DargLine=-DdeleteOrphanedSnapshots
====

TIP: Handling of the parameter is case insensitive.



 
=== Soft assertions
As learned in the previous section, you can easily have multiple snapshot assertions within the same test method. 
Naturally, if the first assertion fails, all subsequent assertions will not be executed, thus potentially hiding further 
problems.

However, there is an option to enable _soft assertions_. That will advice the framework to collect all assertion 
failures and report them in a single stack trace at the end.

[source,java]
.Enable soft assertions
----
include::{sourcedir}/de/skuzzle/test/snapshots/snippets/SoftAssertions.java[tags=softassertions,indent=0]
----

NOTE: _Soft assertions_ are currently only supported on a per-class basis.
  

  
=== Snapshot naming & numbering
==== Multiple assertions 
==== Parameterized tests



=== Snapshot formats
==== JSON
==== XML
==== Custom

== Advanced Topics
=== Random values in test results
=== Snapshot file format
=== Organizing test input in directories

== FAQ

=== Why do we need the JUnit extension instead of just writing an assert?

TIP: Snapshot files can be examined programmatically using the `SnapshotFile` class from the core module.

NOTE: asd

TIP: asdsa

IMPORTANT: test

CAUTION: asdsa

WARNING: test


This page was built by the following command:

 $ mvn

== Images

[.thumb]
image::sunset.jpg[scaledwidth=75%]

== Attributes

.Built-in
asciidoctor-version:: {asciidoctor-version}
safe-mode-name:: {safe-mode-name}
docdir:: {docdir}
docfile:: {docfile}
imagesdir:: {imagesdir}

.Custom
project-version:: {project-version}
sourcedir:: {sourcedir}
endpoint-url:: {endpoint-url}

== Includes

.include::subdir/_b.adoc[]
====
include::subdir/_b.adoc[]
====

WARNING: Includes can be tricky!
